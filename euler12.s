/*
   This is a solution (non-optimal) for Project Eular problem 12.

   What is the value of the first triangle number to have over five hundred divisors???

   The sequence of triangle numbers is generated by adding the natural numbers. 
   So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
   The first ten terms would be:

	1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ... 

   Let us list the factors of the first seven triangle numbers:

		 1: 1
		 3: 1,3
		 6: 1,2,3,6
		10: 1,2,5,10
		15: 1,3,5,15
		21: 1,3,7,21
		28: 1,2,4,7,14,28
   We can see that 28 is the first triangle number to have over five divisors.

   By:         MK Beavers
   Created:    19 Jan 2016
   Platform:   Raspberry Pi V2 (ARMv7)
   Comment:    See www.MathBlog.dx for improved implementation.
               
   pseudo code:
   	tnum = i = 0
   	do
   	    i += 1		//the natural numbers
	    tnum += i           //next triangle number
	    divisors = 1	//add tnum/tnum=1 divisor
   	    for( j = tnum // 2; 0; -1 )	//j == test as divisor
   	        if tnum % j == 0 
		then divisors += 1
   	until divisors > 500
   	print i, tnum, divisors
	end
   	            
   Register Usage:
     R0=scratch and parameter passing
     R1=scratch and parameter passing
     R2=QUOTIENT and parameter passing
     R3=REMAINDER and parameter passing
     R4=i
     R5=tnum
     R6=divisors

   Frame Usage:
    +20	stop_microsec
    +16	stop_sec
    +12	start_microsec
     +8	start_sec
     +4	reserved	To maintain 8-byte alignment
     +0	LinkReg
     fp -----------  
 */
//   REGISTER USAGE
//
QUOTIENT	.req R1
REMAINDER	.req R2
J		.req R3
I		.req R4
TNUM		.req R5
DIVISORS	.req R6
@            sl .req R10  Lexical scope (Position Independent code)
@            fp .req R11  Frame pointer (local variables)
@            ip .req R12    Used by linker for distance branch
@            sp .req R13  Stack Pointer
@            lr .req R14  Link Register
@            pc .req R15  Program Counter

	.data
	.balign  4
RESULTS: .asciz "Eular12: natural #=%d, triangle #=%d, divisors=%d.\n"
RUNTIME: .asciz "Eular12: runtime=%d+%d (in sec+microsec).\n"
	

	.text
	.balign 4
	.global printf
	.global gettimeofday 
 	.global	main
 	.func	main 
main: 
	STR	LR,[SP,#-24]!	@save LinkReg 
	MOV	FP,SP
	STMFD	SP!,{R1-R12}	@save working regs 
@get start time
	ADD	R0,FP,#8	@ &struct timeval
	MOV	R1,#0		@ &struct timezone
	BL	gettimeofday
@initialize variables	
	MOV	I,#0
	MOV	TNUM,I 	
DO:
	ADD	I,#1			
	ADD	TNUM,I		
	MOV	DIVISORS,#1
	MOVS	J,TNUM,LSR #1
	BEQ	PDETAIL		@skip divide by 0
LOOP:
	UDIV	QUOTIENT,TNUM,J	
	MLS 	REMAINDER,QUOTIENT,J,TNUM	
	CMP	REMAINDER,#0
	ADDEQ   DIVISORS,#1	
	SUBS	J,#1 
	BNE	LOOP
PDETAIL:		
@	CMP	DIVISORS,#500	@uncomment these two for
@	BLT	DO	          @the solution to prob12
	LDR	R0,PRTSTR	@print detail
	MOV	R1,I	
	MOV	R2,TNUM
	MOV	R3,DIVISORS
	BL	printf
	CMP	DIVISORS,#200	@change constant to examine
	BLT	DO		  @intermidate TNUMs 
@get stop time	
	ADD	R0,FP,#16
	MOV	R1,#0
	BL	gettimeofday
@compute/print runtime
	ADD	R0,FP,#8
	LDMFD	R0,{R1-R4}
	SUBS	R2,R4,R2 
	SBC	R1,R3,R1
	LDRMI	R0,aMillion	@if negative then
	ADDMI	R2,R0		@fix-up by adding aMillion
	LDR	R0,RTIME
	BL	printf
	MOV	R0,#0		@set 0 return code	
	LDMFD	SP!,{R1-R12}	@restore working regs
	LDR	LR,[SP],#24	@restore LinkReg
	BX	LR		@return to caller
	
PRTSTR:	.word	RESULTS
RTIME:	.word	RUNTIME
aMillion: .word 0xF4240

	.end
